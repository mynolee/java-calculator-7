package calculator;

public class git_summary {
}



/*

머준 아카데미 4월 1주차

공부할 때 단순한 암기가 아니라 왜? 어쩔떄 사용하는가? 어디서 사용해야 적합한가? 를 중점적으로 생각하며 공부하기

1. git

 - git이란?

분산 버전 관리 시스템(DVCS, Distributed Version Control System)
개발자들이 소스 코드를 효율적으로 관리하고 협업할 수 있도록 도와주는 도구

git의 핵심 기능

버전관리 - 코드의 변경 이력을 시간순으로 기록해두고, 이전 버전으로 쉽게 되돌릴 수 ㅇㅇ
분산시스템 - 모든 사용자가 전체 저장소를 복사해서 로컬에서 작업 ㅇㅇ
브랜치 기능 - 여러 작업을 동시에 독립적으로 진행, 나중에 합칠 수 ㅇㅇ. 실험이나 새로운 기능 개발.


명령어	설명
git init	Git 저장소 초기화
git clone [주소]	원격 저장소 복사
git status	현재 변경사항 확인
git add [파일명]	파일을 스테이징 영역에 추가
git commit -m “메세지”	변경사항 커밋(버전 저장)
git push	원격 저장소에 반영
git pull	원격 저장소에서 최신 버전 가져오기
git branch	브랜치 확인/생성/삭제
git merge [브랜치명]	다른 브랜치와 병합

왜 효율적인가.

1.  변경 사항만 저장 (스냅샷 방식).
-전체 파일을 매번 통째로 저장하지 않고 변경된 부분만 저장 - 저장공간도 아끼고, 이력관리도 빠르게 가능
2. 브랜치(branch)시스템으로 독립적인 작업 가능
-git은 브랜치를 아주 가볍고 빠르게 만들 수 있어서 누군가 새로운 기능을 개발하거나 실험할 때 별도의 브랜치에서 마음껏 작업하고 문제가 없으면 메인 코드에 병합(merge) 가능
3.  모든 기록이 남음 (타임머신처럼)
-모든 커밋(commit)은 고유한 ID를 가지고 있어서, 언제든지 이전 상태로 돌아갈 수 ㅇㅇ
-실수했을 때 되돌리기(rollback), 누가 어떤 걸 언제 바꿧는지 추적 가능
4. 협업에 강하다(원격 저장소와 연동)
-git은 github, gitlab, bitbucket 같은 원격저장소와 잘 연동.—>그래서 여러명이 동시에 같은 프로젝트를 작업해도 충돌이 최소화.
—누가 어떤 파일을 수정했는지 추적 가능
—충돌(conflict)도 미리 감지해서 조정 가능
5. 로컬에서 독립적으로 작업 가능
-git은 분산형이라, 인터넷 없어도 로컬에서 버전관리가 가능. —> 서버 장애나 네트워크 문제에도 로컬에서 작업, 히스토리 확인, 브랜치 만들기 등 가능.

———>>git은 “변경 중심의 기록, 브랜치로 독립 작업, 협업 최적화, 되돌리기 가능” 이 조합으로 개발자들이 빠르고 안전하게 작업 가능.


2. github란?
git으로 관리하는 코드를 “인터넷에 올려서” 공유하고 협업할 수 있게 해주는 플랫폼
git을 기반으로 하는 온라인 저장소 서비스
git은 로컬(내 컴퓨터)에서 관리하는 도구
github는 그걸 인터넷에 올려서 여러 사람이 같이 쓸 수 있게 해주는 공간

git - 개인노트, 혼자서 쓰는 버전 관리
github - 클라우드 노트(구글 드라이브 같은거), 전 셰계 사람들이 같이 보는 협업 공간

github로 할 수 있는 것들
-코드 백업(언제 어디서든 접근 가능)
-여러 사람이 같이 협업(pull request, issue 등)
-오픈소스 프로젝트 구경하고 참여하기
-포트폴리오로 사용
-자동 배포, 테스트 등 자동화도 가능(CI/CD)



3. add, commit 의 차이
 git add , git commit 은 git에서 변경 사항을 저장하는 두 단계- 완전 다름

git add “준비 단계”
작업한 파일을 git이 커밋할 준비를 하게 함(스테이징 영역에 올림)
git은 자동 저장이 아님—>이거 저장할게요 하고 표시하는 명령어 —>>add
스태이징(staging area)라는 임시 대기 공간에 올려두는 거

git commit “저장 단계”
스테이징된 변경 사항을 “버전”으로 저장하는 명령어
commit을 하면 git이 스냅샷처럼 저장
메시지(-m “내용”)를 붙여서 왜 이 버전을 남겼는지 설명 ㅇㅇ

git add —장바구니에 담기, 이 파일들 저장할거에요
git commit - 계산하기, 실제로 버전 저장완료

git add - 준비, 변경된 파일을 스테이징 영역에 올림
git commit - 저장, 스테이징된 파일을 하나의 버전으로 저장

git status 로 현재 어떤 파일이 준비됐는지도 확인 가능.



4. fork vs clone

fork - 해당 레포지토리에 write 권한이 없을때 따와서 보통 함
clone -
원본저장소와 fork 저장소의 메인은 fork한 시점에서 완전히 다른 것- 연동 안되니깐 내가 막써도 ㄱㅊ
왜 clone을 쓰냐
fork만써도 되는데
브랜치로 가능?하지만
하나의 브랜치를 여러명이 쓰면 어캄 그럼?
커맨드 r할때마다 계속 달라짐??


clone 하는 이유
내가 편하게 branch,
연동 - 원본저장소랑 내 로컬에 따온 클론이랑
로컬에서 수정이든 뭘새로만들든  - 원본저장소에 pr가능 - merge -



git clone 내부에 리모트랑 컨트롤
원격이랑 내 로컬을 완전히 복붙하기 위해 clone 씀

한줄 요약
github(fork)= 복사본 만드는 곳
git clone = 내 컴퓨터에서 작업하는 도구

github의 fork 기능은 “복사”만 해줌
fork는 내 github계정에 원본 저장소를 복사하는 것
github웹에서 코드를 보거나 브랜치 만들 수는 있지만, 로컬에서 직접 파일 수정, 실행, 커밋, 테스트같은 개발 작업은 불가능

clone은 실제 작업을 위한 필수 단계
git clone은 github에 있는 (원본 또는 fork한)저장소를 내 컴퓨터로 가져오는 것
그 다음
코드 수정, 커밋, 테스트 실행, 브랜치 생성, push, pr요청 —전부 로컬에서 이루어짐

github에서 fork ->내 github저장소로 복사 -> 그 다음에 git clone-> 내컴퓨터로 내려받기 -> 그래야 내가 진짜 개발하고 커밋하고 pr도 보낼수 ㅇㅇ

github웹에서 바로 수정해서 pr만드는 간단한 과정이면 작은 문서 수정 정도는 괜찮지만, 실제 개발엔 clone 이 필수




5. git pull
—git의 원격저장소의 변경사항을 로컬저장소로 가져오는 명령어
—다른사람이 저장소에 올린 최신 내용을 내 컴퓨터에 반영하는 것

git fetch
원격 저장소에서 최신 커밋을 가져오고

git merge
그걸 내 현재 브랜치에 merge(병합)gksms rjt

git pull origin main

origin 은 기본 원격저장소 이름
main은 브랜치 이름


git 충돌(conflict)   — 협업시 자주 겪는 일 두 사람이 같은 파일의 같은 부분을 수정해서 git이 자동으로 어떤걸 반영할지 결정 못할 때 충돌 발생

해결 방법
1.파일 열기 —conflict 구역이 표시됌
2. 수정하기 - 두 버전중 하나 선택 혹은 두 개를 합쳐서 원하는 코드로 바꾸기 3. 수정 파일 저장 4. 충돌 해결 후 add, commit  충돌 난 파일은 git status 로 확인 가능



6. .gitignore
git에서 버전 관리에서 제외할 파일이나 폴더를 지정하는 파일
- git이 무시할 파일 목록을 적어두는 설정 파일
- ex) 컴파일 결과물, ide 설정 파일, 비르 폴더, 민감정보

.gitignore 에 추가해도 이미 git에 올라간 파일은 무시안됌
이미 추적 중인 파일이라면 —git이 이미 한번 버전 관리 대상으로 추가(add)해서 커밋(commit)한 파일
—해당 파일은 git의 이력에 이미 포함
나중에 .gitignore에 파일을 추가해도 gitdl 그 파일을 무시하지 않고 계속 추적하게됌

추적중인 파일을 무시하고 싶다면?
git rm —cached 파일명

이 명령어는 해당 파일을 Git의 추적 대상에서 제거하지만, 로컬 파일 시스템에서는 삭제ㄴ
. 그 후 .gitignore에 추가하면 이후에는 Git이 그 파일을 무시
.gitignore 에 넣고 commit 하면됌



Q)
새로운 Pr을 만들려면 반드시 새로운 브랜치를 만들어야 하는가?
Ans)
꼭 새로운 브랜치를 만들어야 하는 건 아니지만, 그렇게 하는게 베스트 프렉티스—효율적(거의 기본 규칙)

왜 새로운 브랜치를 쓰는게 좋은가?
pr마다 작업내용이 분리됨 -> 기능a, 기능b가 서로 꼬이지 않음
작업 관리가 쉬움 ->pr하나씩 트래킹 가능
충돌 방지 ->main 브랜치 깨끗하게 유지됨
동시 작업 가능 -> 다른 브랜치에서 다른 기능 작업할 수 ㅇㅇ



 */